#!/bin/sh
fail() {
	/bin/echo "Failed"
		/bin/echo "$1"
		exec /bin/sh
}

/bin/mount -o remount,rw / /

PATH=/sbin:/system/sbin:/bin:/system/bin:/system/xbin:/system/xbin/bb:/data/local/bin

/bin/echo "Rootfs loaded."

/bin/mount -t proc proc /proc
/bin/mount -t sysfs sys /sys

/bin/mount | grep mtd
notnand=$?

if [ $notnand = "0" ] ; then
  echo "running from NAND"
  /bin/mount -t yaffs2 /dev/block/mtdblock2 /system
  /bin/mount -t yaffs2 /dev/block/mtdblock3 /data
fi


partition=mmcblk0p1

# Try unpartitioned card
if [ ! -d /sys/block/mmcblk0/$partition ] ; then
	partition=mmcblk0
fi

if [ -f /sys/class/vogue_hw/gsmphone ] ; then
	echo "GSM phone found"
fi

#mkdir -m 0777 /sdcard
#fsck already done in initrd
mount -t vfat -o fmask=0000,dmask=0000,rw,flush,relatime,utf8 /dev/block/$partition /sdcard
[ $? -eq 0 ] || fail "Failed to mount the SD card. Cannot continue."

if [ ! -d /sdcard/cache ] ; then
	mkdir /sdcard/cache
fi

#mkdir -m 0777 /cache
mount /sdcard/cache /cache

CARD_PATH=`/bin/grep -o "rel_path=.*" /proc/cmdline | /bin/sed -e "s/.*rel_path=//g" -e "s/ .*//g"`
if [ "$CARD_PATH" = "" ];then
	CARD_PATH="andboot"
fi;
if [ -d /sdcard/$CARD_PATH ] ; then
	card=/sdcard/$CARD_PATH
else
	card=/sdcard
fi


if [ $notnand = "1" ] ; then
    
    if [ -f $card/data.gz ] ; then
            echo "Please wait... extracting Data Image"
            if [ -f $card/data.img ] ; then
                    rm $card/data.img
            fi
            gzip -df $card/data.gz
            [ $? -eq 0 ] || fail "Failed to extract Data Image"
            mv $card/data $card/data.img
            echo "done"
    fi
    
    if [ -d /sys/block/mmcblk0/mmcblk0p4 ] && /bin/grep -q -v no_partitions /proc/cmdline ; then
	    echo "Using partitioned system"
	    /bin/e2fsck -y /dev/block/mmcblk0p3
	    mount -t ext2 -o ro,relatime /dev/block/mmcblk0p3 /system
	    /bin/e2fsck -y /dev/block/mmcblk0p4
	    mount -t ext2 -o relatime /dev/block/mmcblk0p4 /data
    else
	    echo "Using loopback filesystems"
            if [ ! -f $card/data.img ] ; then
                    echo "Creating a new Data store"
                    dd if=/dev/zero of=$card/data.img bs=1048576 count=256
                    [ $? -eq 0 ] || fail "Failed to allocate the storage"
                    mke2fs -F $card/data.img
                    [ $? -eq 0 ] || fail "Failed to format the storage"
            fi

            losetup /dev/block/loop0 $card/data.img
            [ $? -eq 0 ] || fail "Failed to find data.img on SD Card"
            e2fsck -y /dev/block/loop0
            mount -t ext2 -o relatime /dev/block/loop0 /data

            if      [ -f $card/system.ext2 ] ; then
                    echo "Using uncompressed system"
                    losetup /dev/block/loop1 $card/system.ext2
                    [ $? -eq 0 ] || fail "Failed to reach system.ext2 on SD Card"
                    e2fsck -y /dev/block/loop1
                    mount -t ext2 -o relatime /dev/block/loop1 /system
		    [ $? -eq 0 ] || fail "Failed to mount /system"
            elif    
		    [ -f $card/system.sqsh ] ; then
                    echo "Using SquashFS system"
                    losetup /dev/block/loop1 $card/system.sqsh
                    [ $? -eq 0 ] || fail "Failed to find system.sqsh on SD Card"
                    mount -t squashfs -o ro,relatime /dev/block/loop1 /system
                    [ $? -eq 0 ] || fail "Failed to mount /system"
		    SQUASH=1
            else
                    losetup /dev/block/loop1 $card/system.img
                    [ $? -eq 0 ] || fail "Failed to find system.img on SD Card"
                    mount -t cramfs -o ro,relatime /dev/block/loop1 /system
                    [ $? -eq 0 ] || fail "Failed to mount /system"
            fi
    fi
fi

if [ -f "$card/update.zip" ] && [ ! -f "/sdcard/cache/recovery/intent" ] && [ -z "$SQUASH" ]
then
	RECOVERYCARD=$(echo $card | sed -e 's:/sdcard/:SDCARD\::')

	echo "STARTING OTA UPDATE SYSTEM"
	cp /init.cfg/init.recovery.rc /etc/init.rc
	mkdir /cache/recovery
	echo "--update_package=${RECOVERYCARD}/update.zip" >/cache/recovery/command
	echo "--send_intent=complete" >>/cache/recovery/command
	exec /init.android
fi

# If not updating, ensure old recovery.intent and update.zip files are removed so we can update again later.
rm -f /sdcard/cache/recovery/intent
rm -f $card/update.zip

if [ -d $card/AndroidApps ] ; then
        echo Copying Applications
        if [ ! -d /data/app ] ; then
                mkdir -m 0771 /data/app
        fi
        /bin/cp $card/AndroidApps/* /data/app
        chown -R 1000:1000 /data/app
fi

if [ ! -d $card/media ] ; then
        echo You have no media folder, please extract the resources to your SD card android folder
fi

/bin/rm -rf /data/etc
/bin/mkdir -m 0755 /data/etc
/bin/mkdir -p -m 0700 /data/mnt/secure
/bin/mkdir -p -m 0700 /data/mnt/asec
mount --bind /data/mnt/secure /mnt/secure
mount --bind /data/mnt/asec /mnt/asec
mount /data/etc /etc
cp -a /system/etc/* /etc
cp -ar /init.etc/* /etc/

LCDDENSITY=`/bin/grep -o "lcd.density=.*" /proc/cmdline | /bin/sed -e "s/.*lcd.density=//g" -e "s/ .*//g"`

if [ "$LCDDENSITY" != "" ] ; then
	echo "ro.sf.lcd_density=$LCDDENSITY" >> /etc/default.prop
	echo Setting ro.sf.lcd_density=$LCDDENSITY
fi

if [ ! -d /data/shared_prefs ] ; then
	mkdir -m 0770 /data/shared_prefs
fi
chmod 0770 /data/shared_prefs
chown 1000:1000 /data/shared_prefs
mount /data/shared_prefs /shared_prefs

mount /sdcard/cache /tmp

cp /system/build.prop /tmp/build.prop
KAISER=0
DIAMOND=0
WIFI_TI=0
WIFI_BCM=0
XPERIA=0
WVGA=0
### Is this a Kaiser?
if cat /proc/cpuinfo|grep -q Kaiser ; then
	echo "KAISER detected"
	KAISER=1
	WIFI_TI=1
elif cat /proc/cpuinfo|grep -q Polaris ; then
	echo "POLARIS detected"
	KAISER=1
	WIFI_TI=1
elif cat /proc/cpuinfo|grep -q Diamond ; then
	echo "DIAMOND detected"
	DIAMOND=1
	WIFI_TI=1
elif cat /proc/cpuinfo|grep -q Raphael ; then
	echo "RAPHAEL detected"
	DIAMOND=1
	WIFI_TI=1
elif cat /proc/cpuinfo|grep -q blackstone ; then
	echo "BLACKSTONE detected"
	DIAMOND=1
	WIFI_TI=1
	WVGA=1
elif cat /proc/cpuinfo|grep -q Topaz ; then
	echo "TOPAZ detected"
	DIAMOND=1
	WIFI_TI=1
	WVGA=1
elif cat /proc/cpuinfo|grep -q Kovsky ; then
	echo "XPERIA detected"
	XPERIA=1
	WIFI_TI=1
	WVGA=1
elif cat /proc/cpuinfo|grep -q Rhodium ; then
	echo "RHODIUM detected"
	DIAMOND=1
	WIFI_BCM=1
	WVGA=1
else
	echo "VOGUE detected"
	sed -i s/^wifi/#wifi/ /tmp/build.prop
fi

### Fix su on some builds...
mount --bind /bin/su /system/bin/su 2> /dev/null
mount --bind /bin/su /system/xbin/su 2> /dev/null

RCSCRIPT=""
RCCONFIG=""

echo "Checking for build type..."
if [ -f /system/hero.build ] ; then
	echo "Hero build detected"
	RCSCRIPT="hero"
	RCCONFIG="hero"
	ln /data/app_s /system/app

elif [ -f /system/eclairhero.build ] ; then
	echo "HERO 2.1 BUILD DETECTED -- ECLAIR"
	RCSCRIPT="eclairhero"
	RCCONFIG="eclairhero"
	mount --bind /lib/eclair/hw /system/lib/hw

elif [ -f /system/eclair.build ] ; then
	echo "Eclair build detected"
	RCSCRIPT="eclair"
	RCCONFIG="eclair"
	mount --bind /lib/eclair/hw /system/lib/hw

elif [ -f /system/froyo.build ] ; then
	echo "Froyo build detected"
	RCSCRIPT="froyo"
	RCCONFIG="froyo"
	mount --bind /lib/froyo/hw /system/lib/hw

	# vold: Fix sdcard device location for CDMA boards (thanks paalsteek)
	if [ -d /sys/devices/platform/msm_sdcc.3 ]; then
		/bin/sed -i -e 's:/devices/platform/msm_sdcc\.2:/devices/platform/msm_sdcc.3:g' /etc/vold.fstab
	fi

elif [ -f /system/tattoo.build ] ; then
	echo "Tattoo build detected"
	RCSCRIPT="tattoo"
	RCCONFIG="tattoo"

elif [ -f /system/donut.build ] ; then
	echo "Donut build detected"
	RCSCRIPT="donut"
	RCCONFIG="donut"
	mount --bind /lib/donut/hw /system/lib/hw

elif [ -d /system/lib/donut ] ; then
	echo "Donut build detected"
	RCSCRIPT="donut"
	RCCONFIG="donut"

elif [ -f /system/xrom.build ] ; then
	echo "xROM build detected"
	RCSCRIPT="xrom"
	RCCONFIG="xrom"

elif [ -f /system/rogers.build ] ; then
	echo "Rogers build detected"
	RCSCRIPT="rogers"
	RCCONFIG="rogers"

elif [ -f /system/cyanogen.build ] ; then
	echo "cyanogen experimental detected.....eating donuts"
	RCSCRIPT="cyanogen"
	RCCONFIG="cyanogen"

elif [ -f /system/custom.build ] ; then
	echo "Custom init.rc detected"
	cp /system/sysinit.rc /build.cfg/init.sysinit.rc
	RCCONFIG="hero"
	RCSCRIPT="sysinit"
	
else
	echo "Unknown Android build. Assuming Ion variant"
	RCSCRIPT="ion"
	RCCONFIG="ion"

	# for the fake sensors library
	mount /lib/hw /system/lib/hw -o loop
	chmod 666 /dev/input/event0

	if [ $DIAMOND -eq 1 ] ; then
		RCCONFIG="ion.diamond"
	fi
fi

if [ $KAISER -eq 1 ] ; then
	RCSCRIPT="$RCSCRIPT.kaiser"
fi

if [ $XPERIA -eq 1 ] ; then
	echo "ro.sf.hwrotation=180" >> /etc/default.prop
fi
echo "using /init.$RCSCRIPT.rc as init.rc"
echo "using $card/conf/$RCCONFIG.user.conf"

cp "/init.cfg/init.$RCSCRIPT.rc" /etc/init.rc

#Assume this rootfs.img will be used only on "good" devices
#Meaning raph/diam/blac/

# echo /dev/block/mmcblk0p2 > /sys/devices/platform/usb_mass_storage/lun0/file
ifconfig usb0 192.168.20.1 up
busybox telnetd -b 192.168.20.1 -l /bin/sh
#chmod 4755 /bin/su
#mkdir -m 0777 /smodem
mknod /dev/urandom c 1 9
if [ -d /data/dropbear/ ] ; then
	echo "Starting SSH"
	mknod /dev/random c 1 8
	/bin/dropbear -r /data/dropbear/dropbear_rsa_host_key -s
fi

#Only froyo atm
if [ "$WVGA" = "1" ] && [ "$RCSCRIPT" = "froyo" ];then
	mount --bind /lib/froyo/hw/gralloc.msm7k_wvga.so /lib/froyo/hw/gralloc.msm7k.so
	mount --bind /lib/froyo/hw/gralloc.msm7k_wvga.so /system/lib/hw/gralloc.msm7k.so
fi

if [ "$WIFI_TI" = "1" ] || [ "$WIFI_BCM" = "1" ];then
	if [ -e "$card/modules-$(uname -r).tar.gz" ] && ! `strings /data/modules/wlan.ko 2>/dev/null | grep -q "vermagic=$(uname -r)"`; then
		echo "Installing $card/modules-$(uname -r).tar.gz"
		if [ ! -d "/data/modules" ] ; then
			mkdir /data/modules
		fi
		tar xzf $card/modules-$(uname -r).tar.gz -C /data/modules
		ln -s /data/modules /data/modules/`uname -r`

		[ -f /etc/wifi/wlan.ko ] && rm /etc/wifi/wlan.ko
		cp -R /etc/wifi/* /data/modules/
		depmod
	else
		echo "Modules already unpacked for this kernel version -- skipping installation of $card/modules-$(uname -r).tar.gz"
	fi
	mount --bind /data/modules /lib/modules
	mount --bind /data/modules /system/lib/modules
	sed -i s/^#wifi/wifi/ /tmp/build.prop
fi

if [ -f /system/eclair.build ]
then
	mount --bind /lib/eclair/libhardware_legacy.so /system/lib/libhardware_legacy.so
elif [ -f /system/froyo.build ]
then
	mount --bind /lib/froyo/libhardware_legacy.so /system/lib/libhardware_legacy.so
fi

if [ "$WIFI_TI" = "1" ];then
	if [ "`grep -c ^wifi /tmp/build.prop`" != "2" ]; then
		echo "wifi.interface = tiwlan0" >> /tmp/build.prop
		echo "wifi.supplicant_scan_interval = 45" >> /tmp/build.prop
	fi
fi

if [ "$WIFI_BCM" = "1" ] ;then
	if [ "`grep -c ^wifi /tmp/build.prop`" != "2" ]; then
		echo "wifi.interface = eth0" >> /tmp/build.prop
		echo "wifi.supplicant_scan_interval = 45" >> /tmp/build.prop
	fi

	# fyi: firmware is loaded from /etc/wifi/bcm432x/bcm4325-rtecdc.bin, nvram from /data/wifi-nvram.txt

	mount --bind /etc/wifi/bcm432x/dhcpcd.conf /system/etc/dhcpcd/dhcpcd.conf
	mount --bind /etc/wifi/bcm432x/wpa_supplicant.conf /system/etc/wifi/wpa_supplicant.conf

	# init.rc: fix wpa_supplicant service
	sed -i s/-itiwlan0/-ieth0/ /etc/init.rc
	sed -i s/-Dtiwlan0/-Dwext/ /etc/init.rc

	# init.rc: fix dhcpcd service, wifi.interface, and wpa_supplicant service socket
	sed -i s/tiwlan0/eth0/ /etc/init.rc

	# init.rc:
	sed -i s/user\ wifi/#user\ wifi/ /etc/init.rc
	sed -i s/group\ wifi/#group\ wifi/ /etc/init.rc

	# extract nvram (todo: clean this up/integrate with TI calibration)
	if [ ! -e /data/wifi-nvram.txt ]; then
		for SKIP in 5744 4736;do
			insmod /lib/modules/mtdchar.ko
			mknod /dev/mtd0ro c 90 1
			mkdir /lib/modules/$(uname -r)

			dd if=/dev/mtd0ro of=/tmp/tempcal bs=8192 count=1 skip=$SKIP
			rm /dev/mtd0ro
			rmmod mtdchar
			rmdir /lib/modules/$(uname -r)
			dd if=/tmp/tempcal of=/data/wifi-nvram.txt bs=1 count=466
			rm /tmp/tempcal
		
			if grep nocrc= /data/wifi-nvram.txt 2>&1 > /dev/null;then 
				break
			fi;
		done
		if [ "$SKIP" = "5744" ];then
			echo "CDMA Rhodium detected"
		fi;
		if [ "$SKIP" = "4736" ];then
			echo "GSM Rhodium detected"
		fi;

	fi
fi

mount --bind /tmp/build.prop /system/build.prop

if [ -f "$card/conf/$RCCONFIG.user.conf" ]; then
	/bin/userinit.sh -c "$card/conf/$RCCONFIG.user.conf"
else
	echo "No user config files ($RCCONFIG) found on sdcard"
fi

mount -tdebugfs none /dbgfs
#Activate baclight control
echo 3 > /sys/class/htc_hw/test
#Smooth scroll
echo 40 >/sys/devices/system/cpu/cpu0/cpufreq/ondemand/up_threshold
#Activate full charging
echo 2 > /dbgfs/htc_battery/charger_state

echo 1024 > /dbgfs/micropklt_dbg/sleep_leds

if /bin/grep -c 'physkeyboard=fuze' /proc/cmdline >/dev/null ; then
	echo "USING RAPH110|FUZE LAYOUT"
	cp -f /init.etc/keymaps/fuze_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/fuze_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/fuze_raph_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
elif /bin/grep -c 'physkeyboard=raph' /proc/cmdline >/dev/null ; then
	echo "USING NEW RAPH LAYOUT"
        cp -f /init.etc/keymaps/raphfix_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
elif /bin/grep -c 'physkeyboard=nordic_raph' /proc/cmdline >/dev/null ; then
	echo "USING NEW NORDIC RAPH LAYOUT"
        cp -f /init.etc/keymaps/raphfix_microp-keypad-swedish.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
elif /bin/grep -c 'physkeyboard=german_raph' /proc/cmdline >/dev/null ; then
	echo "USING NEW GERMAN RAPH LAYOUT"
        cp -f /init.etc/keymaps/microp-german.keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
elif /bin/grep -c 'physkeyboard=swiss_raph' /proc/cmdline >/dev/null ; then
	echo "USING NEW SWISS RAPH LAYOUT"
        cp -f /init.etc/keymaps/microp-swiss.keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
elif /bin/grep -c 'physkeyboard=tilt2' /proc/cmdline >/dev/null ; then
	echo "USING EXPERIMENTAL TILT2 LAYOUT"
        cp -f /init.etc/keymaps/tilt2_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/tilt2_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/tilt2_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
elif /bin/grep -c 'physkeyboard=rhod210' /proc/cmdline >/dev/null ; then
	echo "USING EXPERIMENTAL RHOD210 LAYOUT"
        cp -f /init.etc/keymaps/rhod210_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/rhod210_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/rhod210_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
elif /bin/grep -c 'physkeyboard=rhod100_de' /proc/cmdline >/dev/null ; then
	echo "USING RHOD100 DE LAYOUT"
        cp -f /init.etc/keymaps/rhod100_de_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/rhod100_de_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/rhod100_de_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
elif /bin/grep -c 'physkeyboard=rhod100_fr' /proc/cmdline >/dev/null ; then
	echo "USING RHOD100 FR LAYOUT"
        cp -f /init.etc/keymaps/rhod100_fr_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/rhod100_fr_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/rhod100_fr_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
elif /bin/grep -c 'physkeyboard=rhod100_it' /proc/cmdline >/dev/null ; then
	echo "USING RHOD100 IT LAYOUT"
        cp -f /init.etc/keymaps/rhod100_it_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/rhod100_it_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/rhod100_it_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
elif /bin/grep -c 'physkeyboard=rhod100_uk' /proc/cmdline >/dev/null ; then
	echo "USING RHOD100 UK LAYOUT"
        cp -f /init.etc/keymaps/rhod100_uk_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/rhod100_uk_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/rhod100_uk_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
elif /bin/grep -c 'physkeyboard=rhod100_nordic' /proc/cmdline >/dev/null ; then
	echo "USING RHOD100 NORDIC LAYOUT"
        cp -f /init.etc/keymaps/rhod100_nordic_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/rhod100_nordic_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/rhod100_nordic_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
elif /bin/grep -c 'physkeyboard=rhod400' /proc/cmdline >/dev/null ; then
        echo "USING EXPERIMENTAL RHOD400 LAYOUT"
        cp -f /init.etc/keymaps/rhod400_microp-keypad.kl /etc/keymaps/microp-keypad.kl
        cp -f /init.etc/keymaps/rhod400_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
        cp -f /init.etc/keymaps/rhod400_navi_pad.kl /etc/keymaps/raph_navi_pad.kl #does not exist, just following example
elif /bin/grep -c 'physkeyboard=rhod500' /proc/cmdline >/dev/null ; then
        echo "USING EXPERIMENTAL RHOD500 LAYOUT"
        cp -f /init.etc/keymaps/rhod500_microp-keypad.kl /etc/keymaps/microp-keypad.kl
        cp -f /init.etc/keymaps/rhod500_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
        cp -f /init.etc/keymaps/rhod500_navi_pad.kl /etc/keymaps/raph_navi_pad.kl #does not exist, just following example
elif /bin/grep -c 'physkeyboard=kovsq' /proc/cmdline >/dev/null ; then
	echo "USING KOVSKY QWERTY LAYOUT"
	cp -f /init.etc/keymaps/kovsky-qwerty.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/kovsky-qwerty.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
elif /bin/grep -c 'physkeyboard=kovsa' /proc/cmdline >/dev/null; then
	echo "USING KOVSKY AZERTY LAYOUT"
	cp -f /init.etc/keymaps/kovsky-azerty.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/kovsky-azerty.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
else
        echo "USING OLD KEYMAP"
        cp -f /init.etc/keymaps/oldqwerty_microp-keypad.kcm.bin /etc/keymaps/microp-keypad.kcm.bin
	cp -f /init.etc/keymaps/oldqwerty_microp-keypad.kl /etc/keymaps/microp-keypad.kl
	cp -f /init.etc/keymaps/oldqwerty_raph_navi_pad.kl /etc/keymaps/raph_navi_pad.kl
fi

cp -af /init.etc/keymaps/qwerty.kcm.bin /init.etc/keymaps/qwerty.kl /etc/keymaps/
mount --bind /etc/keymaps /system/usr/keychars
mount --bind /etc/keymaps /system/usr/keylayout

for i in /sys/class/input/input* ; do
        if [ "`cat $i/name`" = "tssc-manager" ] ; then
                touchscreendir=$i
                echo "Touchscreen device directory is $i"
        fi
done

if [ -f $card/ts-calibration ] ; then
        echo "Using Saved Touchscreen Calibration"
	echo 128,128,1903,128,128,1907,1903,1907,1024,1024 > $touchscreendir/calibration_screen
        cat $card/ts-calibration > $touchscreendir/calibration_points
else
        mkdir /dev/graphics
        mknod /dev/graphics/fb0 c 29 0
        clear
        echo; echo; echo; echo; echo; echo; echo; echo "Calibrating Touchscreen:"
        echo "Click the Five Targets in order -- Top Left, Top Right, Middle, Bottom Left, Bottom Right"
	echo "(Tap lightly. The screen is quite sensitive.)"
        tssc-calibrate
        echo 0,0,0,0,0,0,0,0,0,0 | cmp -s $touchscreendir/calibration_points # determine if calibration is still null -- means failed calibration
        if [ $? -eq 0 ] ; then
                echo "Touchscreen Calibration Failed"
        else
                echo "Touchscreen Calibration Successful; Saving..."
                cat $touchscreendir/calibration_points > $card/ts-calibration
        fi
fi

mkdir /dev/msm_camera
mknod /dev/msm_camera/control0 c 250 0
mknod /dev/msm_camera/config0 c 250 1
mknod /dev/msm_camera/frame0 c 250 2
chmod a+s /bin/pppd

# Generate a "serial number" for the Android system to identify the device.
# Put it in /data so it survives reboots. Won't survive a factory reset, though.
[ -f "/data/serialno" ] || echo -e `cat /dev/urandom | tr -dc 'A-Z0-9' | fold -w 12 | head -n 1` >/data/serialno

SERIALNO=$(cat /data/serialno)
cp /proc/cmdline /tmp/cmdline
sed -i -e "s:$: androidboot.serialno=${SERIALNO}:" /tmp/cmdline
mount --bind /tmp/cmdline /proc/cmdline

exec /init.android
